(defpackage :dive
  (:use :cl)
  (:export :run-dive)
)
(in-package :dive)

(defstruct command
  cmd
  val
)

(defun delimiterp (c) (or (char= c #\Space) (char= c #\,)))

(defun split (string &key (delimiterp #'delimiterp))
  (loop :for beg = (position-if-not delimiterp string)
    :then (position-if-not delimiterp string :start (1+ end))
    :for end = (and beg (position-if delimiterp string :start beg))
    :when beg :collect (subseq string beg end)
    :while end))

(defun parse-command (line)
  (setq tmp (split line))
  (make-command :cmd (nth 0 tmp)
    :val (parse-integer (nth 1 tmp))
  )
)

(defun get-file (filename)
  (with-open-file (stream filename)
    (loop for line = (read-line stream nil)
      while line
      collect (parse-command line)
    )
  )
)

(defun challenge1 (inputData)
  (setq h 0)
  (setq d 0)
  (dolist (action inputData)
    (setq curcmd (command-cmd action))
    (setq curval (command-val action))
    (when (string= curcmd "forward")
      (setq h (+ h curval))
    )
    (when (string= curcmd "down")
      (setq d (+ d curval))
    )
    (when (string= curcmd "up")
      (setq d (- d curval))
    )
  )
  (* h d)
)

(defun challenge2 (inputData)
  (setq h 0)
  (setq d 0)
  (setq a 0)
  (dolist (action inputData)
    (setq curcmd (command-cmd action))
    (setq curval (command-val action))
    (when (string= curcmd "forward")
      (setq h (+ h curval))
      (setq d (+ d (* a curval)))
    )
    (when (string= curcmd "down")
      (setq a (+ a curval))
    )
    (when (string= curcmd "up")
      (setq a (- a curval))
    )
  )
  (* h d)
)

(defun run-dive ()
  (format t "Day 2 - Dive!~C" #\linefeed)
  (setq fileData (get-file "dive/input.txt"))
  (format t "Challenge 1: ~d~C" (challenge1 fileData) #\linefeed)
  (format t "Challenge 2: ~d~C" (challenge2 fileData) #\linefeed)
)
